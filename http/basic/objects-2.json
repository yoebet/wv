{
  "deprecations": null,
  "objects": [
    {
      "class": "Document_nex1fbd7yxb0pwttcef2q01iybrnkqn0",
      "creationTimeUnix": 1692590262495,
      "id": "4320d66d-7cc6-45dc-9142-4124fffb8878",
      "lastUpdateTimeUnix": 1692590262495,
      "properties": {
        "source": "https://www.cnblogs.com/52php/p/6892651.html",
        "text": "去年学习 Erlang 的时候，建立了速错的理念，简单来讲就是“让它挂”，只有挂了你才会第一时间知道错误。在早期开发以及任何发布阶段之前，最简单的同时也可能是最好的方法是调用 panic 函数来中断程序的执行以强制发生错误，使得该错误不会被忽略，因而能够被尽快修复。\n姿势二：在程序部署后，应恢复异常避免程序终止\n在 Golang 中，虽然有类似 Erlang 进程的 Goroutine，但需要强调的是 Erlang 的挂，只是 Erlang 进程的异常退出，不会导致整个 Erlang 节点退出，所以它挂的影响层面比较低，而 Goroutine 如果 panic 了，并且没有 recover，那么整个 Golang 进程（类似 Erlang 节点）就会异常退出。所以，一旦 Golang 程序部署后，在任何情况下发生的异常都不应该导致程序异常退出，我们在上层函数中加一个延迟执行的 recover 调用来达到这个目的，并且是否进行 recover 需要根据环境变量或配置文件来定，默认需要 recover。\n这个姿势类似于 C 语言中的 断言，但还是有区别：一般在 Release 版本中，断言被定义为空而失效，但需要有 if 校验存在进行异常保护，尽管契约式设计中不建议这样做。在 Golang 中，recover 完全可以终止异常展开过程，省时省力。\n我们在调用 recover 的延迟函数中以最合理的方式响应该异常：\n打印堆栈的异常调用信息和关键的业务信息，以便这些问题保留可见；\n将异常转换为错误，以便调用者让程序恢复到健康状态并继续安全运行。\n我们看一个简单的例子：\n?12345678910111213141516171819202122232425func funcA() error {  defer func() {    if p := recover(); p != nil {      fmt.Printf(\"panic recover! p: %v\", p)      debug.PrintStack()    }  }()  return funcB()} func funcB() error {  // simulation   panic(\"foo\")  return errors.New(\"success\")} func test() {  err := funcA()  if err == nil {    fmt.Printf(\"err is nil\\\\n\")  } else {    fmt.Printf(\"err is %v\\\\n\", err)  }}\n我们期望 test 函数的输出是：\n?1err is foo\n但实际上 test 函数的输出是：\n?1err is nil\n原因是 panic 异常处理机制不会自动将错误信息传递给 error，所以要在 funcA 函数中进行显式的传递，代码如下所示：\n?123456789101112131415func funcA() (err error) {  defer func() {    if p := recover(); p != nil {      fmt.Println(\"panic recover! p:\", p)      str, ok := p.(string)      if ok {        err = errors.New(str)      } else {        err = errors.New(\"panic\")      }      debug.PrintStack()    }  }()  return funcB()}\n姿势三：对于不应该出现的分支，使用异常处理\n当某些不应该发生的场景发生时，我们就应该调用 panic 函数来触发异常。比如，当程序到达了某条逻辑上不可能到达的路径：\n?1234567891011switch s := suit(drawCard()); s {  case \"Spades\":  // ...  case \"Hearts\":  // ...  case \"Diamonds\":  // ...  case \"Clubs\":  // ...  default: panic(fmt.Sprintf(\"invalid suit %v\", s))}\n姿势四：针对入参不应该有问题的函数，使用 panic 设计\n入参不应该有问题一般指的是硬编码，我们先看“一个启示”一节中提到的两个函数（Compile 和 MustCompile），其中 MustCompile 函数是对 Compile 函数的包装：\n?1234567func MustCompile(str string) *Regexp {  regexp, error := Compile(str)  if error != nil {    panic(`regexp: Compile(` + quote(str) + `): ` + error.Error())  }  return regexp}\n所以，对于同时支持用户输入场景和硬编码场景的情况，一般支持硬编码场景的函数是对支持用户输入场景函数的包装。\n对于只支持硬编码单一场景的情况，函数设计时直接使用 panic，即返回值类型列表中不会有 error，这使得函数的调用处理非常方便（没有了乏味的 “if err != nil {/ 打印 && 错误处理 /}” 代码块）。\n小结\n本文以 Golang 为例，阐述了 错误 和 异常 的区别，并且分享了很多 错误 和 异常 处理的正确姿势，这些姿势可以单独使用，也可以组合使用，希望对大家有一点启发。\n延伸阅读：\n[Go] panic 和 recover\n摘自：\nhttp://www.jianshu.com/p/f30da01eea97\n后记\n针对 业务方法 之间 业务错误 处理这一块，其实还可以参考一下先前的文章：\n如何设计PHP业务模块（函数/方法）返回结果的结构？\n分类:\n08.Go基础\n好文要顶\n关注我\n收藏该文\n52php\n粉丝 - 418\n关注 - 0\n+加关注\n0\n0\n«\n上一篇：\n【Go入门教程3】基本类型 和 高级类型\n»\n下一篇：\n微信图片生成插件，页面截图插件 html2canvas，截图失真 问题的解决方案\nposted @\n2017-05-23 11:50\n52php\n阅读(6361)\n评论(1)\n编辑\n收藏\n举报\n弹尽粮绝，会员救园：会员上线，命悬一线\n刷新评论刷新页面返回顶部\n登录后才能查看或发表评论，立即 登录 或者\n逛逛 博客园首页\n【推荐】腾讯2023全球数字生态大会——智变加速，产业焕新，立即预约直播【推荐】行行AI活动预告：揭秘AI+设计私董会训练营——未来设计的新引擎【推荐】阿里云-云服务器省钱攻略 ：五种权益，限时发放，不容错过【推荐】天翼云818全民上云季，爆款云主机2核2G三个月仅47.4元【推荐】SQL专家云：SQL Server 数据库可视化、智能化运维平台\n编辑推荐：\n· 微服务14：微服务治理之重试\n· 领域驱动设计(DDD)：从基础代码探讨高内聚低耦合的演进"
      },
      "vectorWeights": null
    },
    {
      "class": "Document_nex1fbd7yxb0pwttcef2q01iybrnkqn0",
      "creationTimeUnix": 1692590262495,
      "id": "52ef50d1-4abf-4fcc-a554-945146b15de9",
      "lastUpdateTimeUnix": 1692590262495,
      "properties": {
        "source": "https://www.cnblogs.com/52php/p/6892651.html",
        "text": "error 在 Golang 中是如此的流行，以至于很多人设计函数时不管三七二十一都使用 error，即使没有一个失败原因。我们看一下示例代码：\n?1234func (self *CniParam) setTenantId() error {  self.TenantId = self.PodNs  return nil}\n对于上面的函数设计，就会有下面的调用代码：\n?12345err := self.setTenantId()if err != nil {  // log  // free resource return errors.New(...)}\n根据我们的正确姿势，重构一下代码：\n?123func (self *CniParam) setTenantId() {  self.TenantId = self.PodNs}\n于是调用代码变为：\n?1self.setTenantId()\n姿势三：error 应放在返回值类型列表的最后\n对于返回值类型 error，用来传递错误信息，在 Golang 中通常放在最后一个。\n?1234resp, err := http.Get(url)if err != nil {  return nill, err}\nbool 作为返回值类型时也一样。\n?1234value, ok := cache.Lookup(key)if !ok {  // ...cache[key] does not exist…}\n姿势四：错误值统一定义，而不是跟着感觉走\n很多人写代码时，到处 return errors.New(value)，而错误 value 在表达同一个含义时也可能形式不同，比如“记录不存在”的错误 value 可能为：\n\"record is not existed.\"\n\"record is not exist!\"\n\"###record is not existed！！！\"\n...\n这使得相同的错误 value 撒在一大片代码里，当上层函数要对特定错误 value 进行统一处理时，需要漫游所有下层代码，以保证错误 value 统一，不幸的是有时会有漏网之鱼，而且这种方式严重阻碍了错误 value 的重构。\n于是，我们可以参考 C/C++ 的错误码定义文件，在 Golang 的每个包中增加一个错误对象定义文件，如下所示：\n?123456var ERR_EOF = errors.New(\"EOF\")var ERR_CLOSED_PIPE = errors.New(\"io: read/write on closed pipe\")var ERR_NO_PROGRESS = errors.New(\"multiple Read calls return no data or error\")var ERR_SHORT_BUFFER = errors.New(\"short buffer\")var ERR_SHORT_WRITE = errors.New(\"short write\")var ERR_UNEXPECTED_EOF = errors.New(\"unexpected EOF\")\n说明：笔者对于常量更喜欢 C/C++ 的“全大写+下划线分割”的命名方式，读者可以根据团队的命名规范或个人喜好定制。\n姿势五：错误逐层传递时，层层都加日志\n根据笔者经验，层层都加日志非常方便故障定位。\n说明：至于通过测试来发现故障，而不是日志，目前很多团队还很难做到。如果你或你的团队能做到，那么请忽略这个姿势:)\n姿势六：错误处理使用 defer\n我们一般通过判断 error 的值来处理错误，如果当前操作失败，需要将本函数中已经 create 的资源 destroy 掉，示例代码如下：\n?1234567891011121314151617181920212223242526272829func deferDemo() error {  err := createResource1()  if err != nil {    return ERR_CREATE_RESOURCE1_FAILED  }   err = createResource2()  if err != nil {    destroyResource1()    return ERR_CREATE_RESOURCE2_FAILED  }   err = createResource3()  if err != nil {    destroyResource1()    destroyResource2()    return ERR_CREATE_RESOURCE3_FAILED  }   err = createResource4()  if err != nil {    destroyResource1()    destroyResource2()    destroyResource3()    return ERR_CREATE_RESOURCE4_FAILED  }   return nil}\n当 Golang 的代码执行时，如果遇到 defer 的闭包调用，则压入堆栈。当函数返回时，会按照 后进先出 的顺序调用闭包。\n对于闭包的参数是 值传递，而对于外部变量却是 引用传递，所以闭包中的外部变量 err 的值就变成外部函数返回时最新的 err 值。\n根据这个结论，我们重构上面的示例代码：\n?1234567891011121314151617181920212223242526272829303132333435363738func deferDemo() error {  err := createResource1()  if err != nil {    return ERR_CREATE_RESOURCE1_FAILED  }  defer func() {    if err != nil {      destroyResource1()    }  }()   err = createResource2()  if err != nil {    return ERR_CREATE_RESOURCE2_FAILED  }  defer func() {    if err != nil {      destroyResource2()    }  }()   err = createResource3()  if err != nil {    return ERR_CREATE_RESOURCE3_FAILED  }  defer func() {    if err != nil {      destroyResource3()    }  }()   err = createResource4()  if err != nil {    return ERR_CREATE_RESOURCE4_FAILED  }   return nil}\n姿势七：当尝试几次可以避免失败时，不要立即返回错误\n如果错误的发生是偶然性的，或由不可预知的问题导致。一个明智的选择是重新尝试失败的操作，有时第二次或第三次尝试时会成功。在重试时，我们需要限制重试的时间间隔或重试的次数，防止无限制的重试。\n两个案例：\n我们平时上网时，尝试请求某个 URL，有时第一次没有响应，当我们再次刷新时，就有了惊喜。\n团队的一个 QA 曾经建议当 Neutron 的 attach 操作失败时，最好尝试三次，这在当时的环境下验证果然是有效的。\n姿势八：当上层函数不关心错误时，建议不返回 error\n对于一些资源清理相关的函数（destroy/delete/clear），如果子函数出错，打印日志即可，而无需将错误进一步反馈到上层函数，因为一般情况下，上层函数是不关心执行结果的，或者即使关心也无能为力，于是我们建议将相关函数设计为不返回 error。\n姿势九：当发生错误时，不忽略有用的返回值\n通常，当函数返回 non-nil 的 error 时，其他的返回值是未定义的(undefined)，这些未定义的返回值应该被忽略。然而，有少部分函数在发生错误时，仍然会返回一些有用的返回值。比如，当读取文件发生错误时，Read 函数会返回可以读取的字节数以及错误信息。对于这种情况，应该将读取到的字符串和错误信息一起打印出来。\n说明：对函数的返回值要有清晰的说明，以便于其他人使用。\n异常处理的正确姿势\n姿势一：在程序开发阶段，坚持速错"
      },
      "vectorWeights": null
    }
  ],
  "totalResults": 2
}
